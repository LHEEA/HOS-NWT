MODULE reconstruction
!
! This module contains different routines to reconstruct the wavefield
! It uses the modal description of volumic quantities generated by HOS-NWT
!
! Key module for possible coupling using SWENSE method or for output of volumic field
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!    Copyright (C) 2014 - LHEEA Lab., Ecole Centrale de Nantes, UMR CNRS 6598
!
!    This program is part of HOS-NWT
!
!    HOS-NWT is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    This program is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program.  If not, see <http://www.gnu.org/licenses/>.
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
USE type
USE variables
USE fourier_FFTW
USE read_files
!
CONTAINS
!
SUBROUTINE recons_HOS_init(filename,i_unit,n1,n2,n3_add,dt_out_star,T_stop_star,xlen_star,ylen_star,depth_star, &
	modesspecx,modesspecy,modesspecz,modesspect,modesFS,modesFSt,modesadd,modesaddt)
!
IMPLICIT NONE
!
CHARACTER(LEN=*), INTENT(IN) :: filename
INTEGER, INTENT(IN)          :: i_unit
!
! Local variables
INTEGER  :: n1,n2,n3_add
REAL(RP), INTENT(OUT) :: dt_out_star,T_stop_star,xlen_star,ylen_star,depth_star
!
REAL(RP), ALLOCATABLE, DIMENSION(:,:), INTENT(OUT) :: modesspecx,modesspecy,modesspecz,modesspect,modesFS,modesFSt
REAL(RP), ALLOCATABLE, DIMENSION(:,:), INTENT(OUT) :: modesadd,modesaddt
!
! Initialize variables reading filename
! In the file, everything is non-dimensional with L and T length and time scales
CALL init_read_mod(filename,i_unit,n1,n2,dt_out_star,T_stop_star,xlen_star,ylen_star,depth_star)
!
ALLOCATE(modesspecx(n1,n2),modesspecy(n1,n2),modesspecz(n1,n2),modesspect(n1,n2),modesFS(n1,n2),modesFSt(n1,n2))
ALLOCATE(modesadd(n3_add,n2),modesaddt(n3_add,n2))
!
! Read time=0
CALL read_mod(filename,i_unit,0.0_rp,dt_out_star,n1,n2,n3_add,&
	modesspecx,modesspecy,modesspecz,modesspect,modesFS,modesFSt,modesadd,modesaddt)
!
END SUBROUTINE recons_HOS_init
!
!
!
SUBROUTINE reconstruction_FFTs(modesspecx,modesspecy,modesspecz,modesspect,eta,&
	imin,imax,jmin,jmax,zlocal,vitx,vity,vitz,phit,dudt,dvdt,dwdt)
!
! This subroutine reconstructs from modal description all fields necessary for possible coupling using SWENSE method
! or for output of volumic field
! This uses FFTs and consequently can not be used with boundary fitted coordinates
!
IMPLICIT NONE
!% INPUT VARIABLES
REAL(RP), DIMENSION(m1,m2), INTENT(IN) :: modesspecx,modesspecy,modesspecz,modesspect,eta
INTEGER, INTENT(IN) 				   :: imin, imax, jmin, jmax
REAL(RP)      						   :: zlocal
!
! Local variables
REAL(RP) :: coeff, coeff2
INTEGER  :: i1,i2
! Test with FFTs
REAL(RP), DIMENSION(m1,m2) :: a_vitx, a_vity, a_vitz, a_phit, a_dudt, a_dvdt, a_dwdt
REAL(RP), DIMENSION(m1,m2) :: vitx_tmp, vity_tmp, vitz_tmp, phit_tmp, dudt_tmp, dvdt_tmp, dwdt_tmp
!
REAL(RP), DIMENSION(imax-imin+1,jmax-jmin+1), INTENT(OUT) :: vitx,vity,vitz,phit,dudt,dvdt,dwdt
!
! Reconstruction with FFTs... more efficient in all cases?!
!
!
! Constant mode
i1=1
i2=1
a_vitx(i1,i2) = modesspecx(i1,i2)
a_vity(i1,i2) = modesspecy(i1,i2)
a_vitz(i1,i2) = modesspecz(i1,i2)
a_phit(i1,i2) = modesspect(i1,i2)
a_dudt(i1,i2) = -kx(i1)*modesspect(i1,i2)
a_dvdt(i1,i2) = -ky(i2)*modesspect(i1,i2)
a_dwdt(i1,i2) = kth(i1,i2)*modesspect(i1,i2)
!
i1=1
DO i2=2,n2
	IF ((k(i1,i2)*(zlocal+1.0_rp).LT.50.).AND.(k(i1,i2).LT.50.)) THEN
		coeff = COSH(k(i1,i2)*(zlocal+1.0_rp))/COSH(k(i1,i2))
		coeff2= SINH(k(i1,i2)*(zlocal+1.0_rp))/SINH(k(i1,i2))
	ELSE
		coeff = EXP(k(i1,i2)*zlocal)
		coeff2= coeff
	ENDIF
	a_vitx(i1,i2) = modesspecx(i1,i2)*coeff
	a_vity(i1,i2) = modesspecy(i1,i2)*coeff
	a_vitz(i1,i2) = modesspecz(i1,i2)*coeff2
	a_phit(i1,i2) = modesspect(i1,i2)*coeff
	a_dudt(i1,i2) = -kx(i1)*a_phit(i1,i2)
	a_dvdt(i1,i2) = -ky(i2)*a_phit(i1,i2)
	a_dwdt(i1,i2) = kth(i1,i2)*modesspect(i1,i2)*coeff2
ENDDO
!
DO i1=2,n1
	DO i2=1,n2
		IF ((k(i1,i2)*(zlocal+1.0_rp).LT.50.).AND.(k(i1,i2).LT.50.)) THEN
			coeff = COSH(k(i1,i2)*(zlocal+1.0_rp))/COSH(k(i1,i2))
			coeff2= SINH(k(i1,i2)*(zlocal+1.0_rp))/SINH(k(i1,i2))
		ELSE
			coeff = EXP(k(i1,i2)*zlocal)
			coeff2= coeff
		ENDIF
		a_vitx(i1,i2) = modesspecx(i1,i2)*coeff
		a_vity(i1,i2) = modesspecy(i1,i2)*coeff
		a_vitz(i1,i2) = modesspecz(i1,i2)*coeff2
		a_phit(i1,i2) = modesspect(i1,i2)*coeff
		a_dudt(i1,i2) = -kx(i1)*a_phit(i1,i2)
		a_dvdt(i1,i2) = -ky(i2)*a_phit(i1,i2)
		a_dwdt(i1,i2) = kth(i1,i2)*modesspect(i1,i2)*coeff2
	ENDDO
ENDDO
!
! Inverse FFTs
vitx_tmp = fourier_2_space(a_vitx,'sin','cos')
IF (n2.NE.1) THEN
	vity_tmp = fourier_2_space(a_vity,'cos','sin')
	dvdt_tmp = fourier_2_space(a_dvdt,'cos','sin')
ELSE
	vity_tmp = 0.0_rp
	dvdt_tmp = 0.0_rp
ENDIF
vitz_tmp = fourier_2_space(a_vitz,'cos','cos')
phit_tmp = fourier_2_space(a_phit,'cos','cos')
dudt_tmp = fourier_2_space(a_dudt,'cos','cos')
dwdt_tmp = fourier_2_space(a_dwdt,'cos','cos')
!
! Outputs
DO i2=jmin,jmax
	DO i1=imin,imax
		IF((zlocal).GT.eta(i1,i2)) THEN
			vitx(i1-imin+1,i2-jmin+1) = 0.0_rp
			vity(i1-imin+1,i2-jmin+1) = 0.0_rp
			vitz(i1-imin+1,i2-jmin+1) = 0.0_rp
			phit(i1-imin+1,i2-jmin+1) = 0.0_rp
			dudt(i1-imin+1,i2-jmin+1) = 0.0_rp
			dvdt(i1-imin+1,i2-jmin+1) = 0.0_rp
			dwdt(i1-imin+1,i2-jmin+1) = 0.0_rp
		ELSE
			vitx(i1-imin+1,i2-jmin+1) = vitx_tmp(i1,i2)
			vity(i1-imin+1,i2-jmin+1) = vity_tmp(i1,i2)
			vitz(i1-imin+1,i2-jmin+1) = vitz_tmp(i1,i2)
			phit(i1-imin+1,i2-jmin+1) = phit_tmp(i1,i2)
			dudt(i1-imin+1,i2-jmin+1) = dudt_tmp(i1,i2)
			dvdt(i1-imin+1,i2-jmin+1) = dvdt_tmp(i1,i2)
			dwdt(i1-imin+1,i2-jmin+1) = dwdt_tmp(i1,i2)
		ENDIF
	ENDDO
ENDDO
!
END SUBROUTINE reconstruction_FFTs
!
!
!
SUBROUTINE reconstruction_add_FFTs(modesadd,modesaddt,eta,imin,imax,jmin,jmax,zlocal,&
				phixadd,phiyadd,phizadd,phitadd,phixtadd,phiytadd,phiztadd)
!
! This subroutine reconstructs from modal description all fields necessary for possible coupling using SWENSE method
! or for output of volumic field (additional part: wavemaker contribution)
! This uses FFTs and consequently can not be used with boundary fitted coordinates
!
IMPLICIT NONE
!
REAL(RP), DIMENSION(m3_add,m2), INTENT(IN) :: modesadd,modesaddt
REAL(RP), DIMENSION(m1,m2), INTENT(IN)     :: eta
REAL(RP), INTENT(IN) :: zlocal
INTEGER, INTENT(IN) :: imin,imax,jmin,jmax
REAL(RP), DIMENSION(imax-imin+1,jmax-jmin+1), INTENT(OUT) :: phixadd,phiyadd,phizadd,phitadd,phixtadd,phiytadd,phiztadd
!
! Local variables
INTEGER  :: i1,i2,ii2,ii3
REAL(RP) :: coskx_add,sinkx_add,coeff1,coeff2,coeff3,coeff4
!
REAL(RP), DIMENSION(m2) :: phixadd_l,phiyadd_l,phizadd_l,phitadd_l,phixtadd_l,phiytadd_l,phiztadd_l
!
DO i1=imin,imax
	DO ii2=1,n2
		phitadd_l(ii2)  = 0.0_rp
		phixadd_l(ii2)  = 0.0_rp
		phiyadd_l(ii2)  = 0.0_rp
		phizadd_l(ii2)  = 0.0_rp
		!
		phixtadd_l(ii2) = 0.0_rp
		phiytadd_l(ii2) = 0.0_rp
		phiztadd_l(ii2) = 0.0_rp
		!
		DO ii3=1,n3_add
         	coskx_add = cos(kx_add(ii3) * (zlocal+1.0_rp))
         	sinkx_add = sin(kx_add(ii3) * (zlocal+1.0_rp))
         	!
			coeff1 = coskx_add * csh_add_x(i1,ii2,ii3)
			coeff2 = sinkx_add * kx_add_csh_add_x(i1,ii2,ii3)
			coeff3 = coskx_add * k_add_sh_add_x(i1,ii2,ii3)
			coeff4 = coskx_add * kycsh_add_x(i1,ii2,ii3)
			!
			phitadd_l(ii2)    =  phitadd_l(ii2)  +  modesaddt(ii3,ii2) * coeff1 
			phixadd_l(ii2)    =  phixadd_l(ii2)  -  modesadd(ii3,ii2)  * coeff3 
			phiyadd_l(ii2)    =  phiyadd_l(ii2)  -  modesadd(ii3,ii2)  * coeff4 
			phizadd_l(ii2)    =  phizadd_l(ii2)  -  modesadd(ii3,ii2)  * coeff2 
			!
			phixtadd_l(ii2)    =  phixtadd_l(ii2)  -  modesaddt(ii3,ii2) * coeff3 
			phiytadd_l(ii2)    =  phiytadd_l(ii2)  -  modesaddt(ii3,ii2) * coeff4
			phiztadd_l(ii2)    =  phiztadd_l(ii2)  -  modesaddt(ii3,ii2) * coeff2 
		ENDDO
	ENDDO
	phitadd_l  = fourier_2_space_y(phitadd_l,'cos')
	phixadd_l  = fourier_2_space_y(phixadd_l,'cos')
	phiyadd_l  = fourier_2_space_y(phiyadd_l,'sin')
	phizadd_l  = fourier_2_space_y(phizadd_l,'cos')
	phixtadd_l = fourier_2_space_y(phixtadd_l,'cos')
	phiytadd_l = fourier_2_space_y(phiytadd_l,'sin')
	phiztadd_l = fourier_2_space_y(phiztadd_l,'cos')
	!
	DO i2=jmin,jmax
		IF((zlocal).GT.eta(i1,i2)) THEN
			phitadd(i1-imin+1,i2-jmin+1)   = 0.0_rp
			phixadd(i1-imin+1,i2-jmin+1)   = 0.0_rp
			phiyadd(i1-imin+1,i2-jmin+1)   = 0.0_rp
			phizadd(i1-imin+1,i2-jmin+1)   = 0.0_rp
			phixtadd(i1-imin+1,i2-jmin+1)  = 0.0_rp
			phiytadd(i1-imin+1,i2-jmin+1)  = 0.0_rp
			phiztadd(i1-imin+1,i2-jmin+1)  = 0.0_rp
		ELSE
			phitadd(i1-imin+1,i2-jmin+1)   = phitadd_l(i2)
			phixadd(i1-imin+1,i2-jmin+1)   = phixadd_l(i2)
			phiyadd(i1-imin+1,i2-jmin+1)   = phiyadd_l(i2)
			phizadd(i1-imin+1,i2-jmin+1)   = phizadd_l(i2)
			phixtadd(i1-imin+1,i2-jmin+1)  = phixtadd_l(i2)
			phiytadd(i1-imin+1,i2-jmin+1)  = phiytadd_l(i2)
			phiztadd(i1-imin+1,i2-jmin+1)  = phiztadd_l(i2)
		ENDIF
	ENDDO
ENDDO
!
END SUBROUTINE reconstruction_add_FFTs
!
!
!
SUBROUTINE reconstruction_direct(modesspecx,modesspecy,modesspecz,modesspect,eta,&
	imin,imax,jmin,jmax,zmin,ii3,i_zvect,vitx,vity,vitz,phit,dudt,dvdt,dwdt,zvect)
!
! This subroutine reconstructs from modal description all fields necessary for possible coupling using SWENSE method
! or for output of volumic field
! This uses direct method and consequently must be used with boundary fitted coordinates
!
IMPLICIT NONE
!% INPUT VARIABLES
REAL(RP), DIMENSION(m1,m2), INTENT(IN) :: modesspecx,modesspecy,modesspecz,modesspect,eta
INTEGER, INTENT(IN) 				   :: imin, imax, jmin, jmax, ii3, i_zvect
REAL(RP) , INTENT(IN)				   :: zmin
!
REAL(RP), DIMENSION(imax-imin+1,jmax-jmin+1), INTENT(OUT)  :: vitx,vity,vitz,phit,dudt,dvdt,dwdt,zvect
!
REAL(RP) , DIMENSION(imax-imin+1) :: xvect
REAL(RP) , DIMENSION(jmax-jmin+1) :: yvect

REAL(RP) :: coeff, coeff2, coscos, cossin, sincos
INTEGER  :: i1,i2,ii1,ii2
!
! Direct method
! Define discretization between zmin and eta
!
do i1=1,imax-imin+1
	do i2=1,jmax-jmin+1
		xvect(i1) = x(i1+imin-1)
		yvect(i2) = y(i2+jmin-1)
		! Linear description of zvect
		!zvect(ii1,ii2)=zmin+(-zmin+eta_tmp(ii1+imin-1,ii2+jmin-1))*REAL(ii3-1,RP)/REAL(i_zvect-1,RP)
		! Stretched grid of zvect
		zvect(i1,i2)=zmin+(-zmin+eta(i1+imin-1,i2+jmin-1))*SIN(pio2*REAL(ii3-1,RP)/REAL(i_zvect-1,RP))
	enddo
enddo
!
! Loop over the position
DO i1=1,imax-imin+1
	DO i2=1,jmax-jmin+1
		!
		! Constant mode
		ii1=1
		ii2=1
		!
		coscos = COS(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
		cossin = COS(kx(ii1)*xvect(i1))*SIN(ky(ii2)*yvect(i2))
		sincos = SIN(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
		!
		vitx(i1,i2) = modesspecx(ii1,ii2)*sincos
		vity(i1,i2) = modesspecy(ii1,ii2)*cossin
		vitz(i1,i2) = modesspecz(ii1,ii2)*coscos
		phit(i1,i2) = modesspect(ii1,ii2)*coscos
		dudt(i1,i2) = -kx(ii1)*modesspect(ii1,ii2)*sincos
		dvdt(i1,i2) = -ky(ii2)*modesspect(ii1,ii2)*cossin
		dwdt(i1,i2) = kth(ii1,ii2)*modesspect(ii1,ii2)*coscos
		!
		ii1=1
		DO ii2=2,n2
			IF ((k(ii1,ii2)*(zvect(i1,i2)+1.0_rp).LT.50.).AND.(k(ii1,ii2).LT.50.)) THEN
				coeff = COSH(k(ii1,ii2)*(zvect(i1,i2)+1.0_rp))/COSH(k(ii1,ii2))
				coeff2= SINH(k(ii1,ii2)*(zvect(i1,i2)+1.0_rp))/SINH(k(ii1,ii2))
			ELSE
				coeff = EXP(k(ii1,ii2)*zvect(i1,i2))
				coeff2= coeff
			ENDIF
			!
			coscos = COS(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
			cossin = COS(kx(ii1)*xvect(i1))*SIN(ky(ii2)*yvect(i2))
			sincos = SIN(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
			!
			vitx(i1,i2) = vitx(i1,i2)+modesspecx(ii1,ii2)*coeff*sincos
			vity(i1,i2) = vity(i1,i2)+modesspecy(ii1,ii2)*coeff*cossin
			vitz(i1,i2) = vitz(i1,i2)+modesspecz(ii1,ii2)*coeff2*coscos
			phit(i1,i2) = phit(i1,i2)+modesspect(ii1,i2)*coeff*coscos
			dudt(i1,i2) = dudt(i1,i2)-kx(ii1)*modesspect(ii1,i2)*coeff*sincos
			dvdt(i1,i2) = dvdt(i1,i2)-ky(ii2)*modesspect(ii1,i2)*coeff*cossin
			dwdt(i1,i2) = dwdt(i1,i2)+kth(ii1,ii2)*modesspect(ii1,ii2)*coeff2*coscos
		ENDDO
		!
		DO ii1=2,n1
			DO ii2=1,n2
				IF ((k(ii1,ii2)*(zvect(i1,i2)+1.0_rp).LT.50.).AND.(k(ii1,ii2).LT.50.)) THEN
					coeff = COSH(k(ii1,ii2)*(zvect(i1,i2)+1.0_rp))/COSH(k(ii1,ii2))
					coeff2= SINH(k(ii1,ii2)*(zvect(i1,i2)+1.0_rp))/SINH(k(ii1,ii2))
				ELSE
					coeff = EXP(k(ii1,ii2)*zvect(i1,i2))
					coeff2= coeff
				ENDIF
				!
				coscos = COS(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
				cossin = COS(kx(ii1)*xvect(i1))*SIN(ky(ii2)*yvect(i2))
				sincos = SIN(kx(ii1)*xvect(i1))*COS(ky(ii2)*yvect(i2))
				!
				vitx(i1,i2) = vitx(i1,i2)+modesspecx(ii1,ii2)*coeff*sincos
				vity(i1,i2) = vity(i1,i2)+modesspecy(ii1,ii2)*coeff*cossin
				vitz(i1,i2) = vitz(i1,i2)+modesspecz(ii1,ii2)*coeff2*coscos
				phit(i1,i2) = phit(i1,i2)+modesspect(ii1,i2)*coeff*coscos
				dudt(i1,i2) = dudt(i1,i2)-kx(ii1)*modesspect(ii1,i2)*coeff*sincos
				dvdt(i1,i2) = dvdt(i1,i2)-ky(ii2)*modesspect(ii1,i2)*coeff*cossin
				dwdt(i1,i2) = dwdt(i1,i2)+kth(ii1,ii2)*modesspect(ii1,ii2)*coeff2*coscos
			ENDDO
		ENDDO	
	ENDDO
ENDDO
!
END SUBROUTINE reconstruction_direct
!
!
!
SUBROUTINE reconstruction_add_direct(modesadd,modesaddt,imin,imax,jmin,jmax,zvect,&
	phixadd,phiyadd,phizadd,phitadd,phixtadd,phiytadd,phiztadd)
!
! This subroutine reconstructs from modal description all fields necessary for possible coupling using SWENSE method
! or for output of volumic field (additional part : wavemaker contribution)
! This uses direct method and consequently must be used with boundary fitted coordinates
!
IMPLICIT NONE
!
!% INPUT VARIABLES
REAL(RP), DIMENSION(m3_add,m2), INTENT(IN) :: modesadd,modesaddt
INTEGER, INTENT(IN) 				       :: imin, imax, jmin, jmax
!
REAL(RP), DIMENSION(imax-imin+1,jmax-jmin+1), INTENT(IN)   :: zvect
!
REAL(RP), DIMENSION(imax-imin+1,jmax-jmin+1), INTENT(OUT)  :: phixadd,phiyadd,phizadd,phitadd,phixtadd,phiytadd,phiztadd
!
INTEGER  :: i1,i2,ii2,ii3
REAL(RP) :: coskx_add,sinkx_add,cosky,coeff1,coeff2,coeff3,coeff4
!
DO i1=1,imax-imin+1
	DO i2=1,jmax-jmin+1
		phixadd(i1,i2)  = 0.0_rp
		phiyadd(i1,i2)  = 0.0_rp
		phizadd(i1,i2)  = 0.0_rp
		phitadd(i1,i2)  = 0.0_rp
		phixtadd(i1,i2) = 0.0_rp
		phiytadd(i1,i2) = 0.0_rp
		phiztadd(i1,i2) = 0.0_rp
		!
		DO ii2=1,n2
			DO ii3=1,n3_add
				coskx_add = cos(kx_add(ii3) * (zvect(i1,i2)+1.0_rp))
				sinkx_add = sin(kx_add(ii3) * (zvect(i1,i2)+1.0_rp))
				cosky     = cos(ky(ii2)*y(i2+jmin-1))
				!
				coeff1 = coskx_add * csh_add_x(i1+imin-1,ii2,ii3)        * cosky
				coeff2 = sinkx_add * kx_add_csh_add_x(i1+imin-1,ii2,ii3) * cosky
				coeff3 = coskx_add * k_add_sh_add_x(i1+imin-1,ii2,ii3)   * cosky
				coeff4 = coskx_add * kycsh_add_x(i1+imin-1,ii2,ii3)      * sin(ky(ii2)*y(i2+jmin-1))
				!
				phitadd(i1,i2)    =  phitadd(i1,i2)  +  modesaddt(ii3,ii2) * coeff1 
				phixadd(i1,i2)    =  phixadd(i1,i2)  -  modesadd(ii3,ii2)  * coeff3 
				phiyadd(i1,i2)    =  phiyadd(i1,i2)  -  modesadd(ii3,ii2)  * coeff4 
				phizadd(i1,i2)    =  phizadd(i1,i2)  -  modesadd(ii3,ii2)  * coeff2 
				!
				phixtadd(i1,i2)    =  phixtadd(i1,i2)  -  modesaddt(ii3,ii2) * coeff3 
				phiytadd(i1,i2)    =  phiytadd(i1,i2)  -  modesaddt(ii3,ii2) * coeff4
				phiztadd(i1,i2)    =  phiztadd(i1,i2)  -  modesaddt(ii3,ii2) * coeff2 
			ENDDO
		ENDDO
	ENDDO
ENDDO
!
END SUBROUTINE reconstruction_add_direct
!
!
!
SUBROUTINE build_mesh_global(xlen,ylen,n1,n2,n3,n3_add,x,y,kx,ky,k,kth,&
	kx_add, kx2_add,k_add, k_add_2, k_add_thk_add,k_add_sh_add_x, kycsh_add_x, kx_add_csh_add_x)
!
IMPLICIT NONE
!
REAL(RP), INTENT(IN) :: xlen, ylen
INTEGER, INTENT(IN)  :: n1,n2,n3,n3_add
!!
REAL(RP), DIMENSION(n1,n2), INTENT(OUT)        :: k,kth
REAL(RP), DIMENSION(n1), INTENT(OUT)           :: x,kx
REAL(RP), DIMENSION(n2), INTENT(OUT)           :: y,ky
!
REAL(RP), DIMENSION(n3_add), INTENT(OUT)       :: kx_add, kx2_add
REAL(RP), DIMENSION(n3_add,n2), INTENT(OUT)    :: k_add, k_add_2, k_add_thk_add
!
REAL(RP), DIMENSION(n1,n2,n3_add), INTENT(OUT) :: k_add_sh_add_x, kycsh_add_x, kx_add_csh_add_x
! Local variables
REAL(RP) :: pixlen, piylen, delx, dely, delz
INTEGER  :: i1,i2,i3
!
REAL(RP), DIMENSION(n1) :: kx2
REAL(RP), DIMENSION(n2) :: ky2
REAL(RP), DIMENSION(n3) :: cx_add, cz
!
REAL(RP) :: pixlen_add, xlen_add
REAL(RP) :: k_add_X_max, k_add_x, k_add_x1, k_add_x2, expon1, expon2, expon12, expon3, expon3p1, csh_add, sh_add
REAL(RP), DIMENSION(n3_add) :: cs_add, s_add, k_add_s_add ! check if it is useful those values???
!
INTEGER :: l_add
!
! FIXME: l_add should be put in mod_file probably... so that you do not assume a given size
l_add    = 2
xlen_add = 2.d0 * REAL(l_add)
!
!   mesh generation
delx = xlen / (n1 - 1)
delz = 1.d0 / (n3 - 1)
!
if (n2.ne.1) then
   dely = ylen / (n2 - 1)
else
   dely = 0.d0
endif
!
do i2 = 1, n2
   y(i2) = (i2 - 1) * dely
end do
!
do i1 = 1,n1
   x(i1) = (i1 - 1) * delx
end do
!
do i3=1,n3
   cx_add(i3) = delz*(i3-1)
   cz(i3)   = cx_add(i3)-1.d0
end do
!     __________________________________________________________________
!
!% SPECTRAL RESOLUTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
!     __________________________________________________________________
!
!	wave numbers
!
pixlen=pi/xlen
!
IF (n2 /= 1) THEN
   piylen=pi/ylen
ELSE
   piylen=0.d0
ENDIF
!
DO i2=1,n2
   ky(i2)  = (i2-1) * piylen
   ky2(i2) = ky(i2) * ky(i2)
ENDDO
!
DO i1 = 1, n1
   kx(i1)  = (i1-1) * pixlen
   kx2(i1) = kx(i1) * kx(i1)
   DO i2 = 1, n2
      k(i1,i2)     = SQRT(kx2(i1) + ky2(i2))
      kth(i1,i2)   = k(i1,i2)*TANH(k(i1,i2))
   ENDDO
ENDDO
!
! on the wavemaker surface
pixlen_add = PI / xlen_add
!
! wavemaker modes part
DO i3 = 1, n3_add
   kx_add(i3)  = (2*i3-1) * pixlen_add
   kx2_add(i3) = kx_add(i3) * kx_add(i3)
   DO i2 = 1, n2
      k_add(i3,i2)  = SQRT(kx2_add(i3) + ky2(i2))
      k_add_2(i3,i2) = 2.0_rp * k_add(i3,i2) ! GD : to check
      k_add_thk_add(i3,i2) = k_add(i3,i2) * dtanh(k_add(i3,i2) * xlen) ! on the wavemaker
   ENDDO
ENDDO
!	    
! wavemaker modes part
k_add_X_max = 700.0_rp
!
DO i3 = 1, n3_add
   cs_add(i3)   = COS(kx_add(i3))
   s_add(i3)    = SIN(kx_add(i3))
   k_add_s_add(i3) = kx_add(i3) * SIN(kx_add(i3))
   !
   DO i2 = 1, n2
      k_add_x = k_add_2(i3,i2) * xlen
      !
      IF (k_add_x <= k_add_X_max) THEN
         expon3 = EXP(-k_add_2(i3,i2) * xlen)
      ELSE
         expon3 = 0.0_rp  
      END IF
      !
      expon3p1  = expon3 + 1.d0
      DO i1 = 1, n1	                             ! on the free surface
         k_add_x1 = k_add(i3,i2) * x(i1)
         !
         IF (k_add_x1 <= k_add_X_max) THEN
            expon1    = EXP(-k_add_x1) / expon3p1
         ELSE
            expon1 = 0.0_rp  
         END IF
         !
         k_add_x2 = k_add_2(i3,i2) * (xlen - x(i1))
         IF (k_add_x2 <= k_add_X_max) THEN
            expon2    = EXP(- k_add_x2)
         ELSE
            expon2 = 0.0_rp  
         END IF
         !
         IF (k_add_x1 + k_add_x2 <= k_add_x_max) THEN
            expon12   = expon1 * expon2
         ELSE
            expon12   = 0.0_rp
         END IF
         !
         csh_add     = expon1 + expon12
         sh_add      = expon1 - expon12
         csh_add_x(i1,i2,i3)     = csh_add
         k_add_sh_add_x(i1,i2,i3)   = sh_add * k_add(i3,i2)
         kycsh_add_x(i1,i2,i3)      = csh_add * ky(i2)
         kx_add_csh_add_x(i1,i2,i3) = csh_add * kx_add(i3)
      ENDDO
   ENDDO
ENDDO
!
END SUBROUTINE build_mesh_global
!
!
!
SUBROUTINE build_mesh_local(x_min,x_max,y_min,y_max,z_min,z_max,xlen_star,ylen_star,L,n1,n2,nz,&
	xvect,yvect,zvect,imin,imax,jmin,jmax)
!
IMPLICIT NONE
!
REAL(RP), INTENT(IN)                  :: x_min,x_max,y_min,y_max,z_min,z_max,xlen_star,ylen_star,L
INTEGER, INTENT(IN)                   :: n1,n2,nz
!
REAL(RP), ALLOCATABLE, DIMENSION(:), INTENT(OUT)   :: xvect, yvect, zvect
INTEGER, INTENT(OUT)                               :: imin,imax,jmin,jmax
!
! Local variables
REAL(RP) :: delx, dely
INTEGER  :: i_xvect,i_yvect,i_zvect,i1,i2
!
delx = xlen_star / (n1-1)
!
IF (n2 == 1) THEN
   dely = 0.0_rp
ELSE
   dely = ylen_star / (n2-1)
END IF
!
imin = MAX(1,FLOOR(x_min/L/delx) + 1)
imax = MIN(n1,CEILING(x_max/L/delx) + 1)
if(n2.NE.1) then
	jmin = MAX(1,FLOOR(y_min/L/dely) + 1)
	jmax = MIN(n2,CEILING(y_max/L/dely) + 1)
else
	jmin = 1
	jmax = 1
endif
!
i_xvect = imax-imin+1
i_yvect = jmax-jmin+1
i_zvect = nz !FIXME: what do I have to choose.
!
ALLOCATE(xvect(i_xvect), yvect(i_yvect), zvect(i_zvect))
!
DO i1 = 1, i_xvect
	xvect(i1) = x(i1+imin-1)
ENDDO
DO i2 = 1, i_yvect
	yvect(i2) = y(i2+jmin-1)
ENDDO
!
! Define zvect
DO i1 = 1, i_zvect/2
	zvect(i1) = z_min/L+(i1-1)*(-z_min-z_max)/(L*(i_zvect/2-1)) !FIXME: in which zone does it need refinement?
ENDDO
DO i1 = i_zvect/2+1, i_zvect
	zvect(i1) = zvect(i_zvect/2)+(i1-(i_zvect/2+1)+1)*2.0_rp*z_max/(L*(i_zvect-(i_zvect/2+1)+1))
ENDDO
!
END SUBROUTINE build_mesh_local
!
!
!
SUBROUTINE check_sizes(n2,x_min,x_max,y_min,y_max,z_min,t_min,t_max,xlen_star,ylen_star,T_stop_star,L,T)
!
! Test the domain size and time window
!
IMPLICIT NONE
!
INTEGER, INTENT(IN)  :: n2
REAL(RP), INTENT(IN) :: x_min,x_max,y_min,y_max,z_min,t_min,t_max,xlen_star,ylen_star,T_stop_star,L,T
!
! Local variables
REAL(RP)             :: tiny_sp
!
! tiny_sp is single precision: useful for inequalities check with values read from files
tiny_sp = epsilon(1.0)
!
IF(x_max.GT.(xlen_star+tiny_sp)*L) THEN
	WRITE(*,*) 'Warning, length of HOS-NWT domain exceeded'
	WRITE(*,*) 'xmax =',x_max,'xlen =',xlen_star*L
	STOP
ENDIF
IF(x_min.LT.(-tiny_sp)) then
	WRITE(*,*) 'Warning, negative x location'
	WRITE(*,*) 'xmin =',x_min
	STOP
ENDIF
IF(n2 /= 1) then
   IF(y_max.GT.(ylen_star+tiny_sp)*L) then
      WRITE(*,*) 'Warning, length of HOS-NWT domain exceeded'
      WRITE(*,*) 'ymax =',y_max,'ylen =',ylen_star*L
      STOP
   ENDIF
   IF(y_min.LT.(-tiny_sp)) then
      WRITE(*,*) 'Warning, negative y location'
      WRITE(*,*) 'ymin =',y_min
      STOP
   ENDIF
ENDIF
IF(t_max.GT.(T_stop_star+tiny_sp)*T) THEN
	WRITE(*,*) 'Warning, duration of HOS-NWT simulation exceeded'
	WRITE(*,*) 'tmax =',t_max,'T_stop =',T_stop_star*T
	STOP
ENDIF
IF(t_min.LT.(-tiny_sp)) then
	WRITE(*,*) 'Warning, negative starting time'
	WRITE(*,*) 'tmin =',t_min
	STOP
ENDIF
IF(z_min.LT.(-L-tiny_sp)) then
	WRITE(*,*) 'Warning, |z_min| is greater than water depth'
	WRITE(*,*) 'zmin =',z_min
	STOP
ENDIF
!
END SUBROUTINE check_sizes
!
END MODULE reconstruction